from django.shortcuts import render_to_response,render
from django.template import RequestContext
from django.http import HttpResponseRedirect,Http404,HttpResponse
from django.contrib import auth
from django.contrib.auth.models import User
from django.core.exceptions import ObjectDoesNotExist
from django.contrib.auth import authenticate, login
from checkmate.main.models import *
from django.contrib.auth.decorators import login_required
from checkmate.main.forms import *
from django.db import IntegrityError
import json

def login(request):
	if request.user.is_authenticated():
		return HttpResponseRedirect('/')
	if request.POST:
		form=LoginForm(request.POST)
		if form.is_valid():	
			data=form.cleaned_data
			username = data['username']
			password = data['password']
			user = authenticate(username=username, password=password)
			if user is not None:
				if user.is_active:
					auth.login(request, user)
					return HttpResponseRedirect('/')
					
				else:
					state = "Your account is not active, please contact the site admin."
					return render_to_response('LOGINhtml.html', {'form':form,'state':state},context_instance=RequestContext(request))
					
			else:
				state = "Your username and/or password were incorrect."
				return render_to_response('LOGINhtml.html', {'form':form,'state':state},context_instance=RequestContext(request))
		else:
			return render_to_response('LOGINhtml.html', {'form':form},context_instance=RequestContext(request))
			
	else:
		form=LoginForm()
		return render_to_response('LOGINhtml.html', {'form':form},context_instance=RequestContext(request))

@login_required
def question(request) :
	if request.method== "POST":
		no = int(request.POST['no',])
	#if request.method== "GET":
	#	no=int(request.GET.get['no'])
	u=request.user
	try:
		up=UserProfile.objects.get(user=u)
	except ObjectDoesNotExist:
		raise Http404
	try:
		ques=Question.objects.get(no=no)
	except:
		raise Http404
	resp={}
	resp['status']=1
	if request.method=="POST" and 'answer' in request.POST:
		data=request.POST
		qas=up.qa
		for i in qas:
			if no==i.no:
				resp['status']=0
				break
		if data['answer'].lower()==ques.answer&resp['status']==1:
			up.qa.add(ques)
			if ques.difficulty==1:
				up.score+=50
			elif ques.difficulty==2:
				up.score+=100
			elif ques.difficulty==3:
				up.score+=150
		elif data['answer'].lower()!=ques.answer:
											#deduct points for wrong answer
			resp['status']=0
			
	resp['score']=up.score
	resp['qno']=q.no
	json = json.dumps(resp)								#do simplejson if reqd
	return HttpResponse(json, mimetype='application/json')			




	
@login_required
def main(request):
	u=request.user
	up=UserProfile.objects.get(user=u)
	eqset=Question.objects.filter(difficulty=1)
	mqset=Question.objects.filter(difficulty=2)
	dqset=Question.objects.filter(difficulty=3)
	return render_to_response('index.html', {'qset':qset,'up':up},context_instance=RequestContext(request))

def rulebook(request):
	 return render_to_response('rulebook.html',context_instance=RequestContext(request))

@login_required
def arena(request):
	u=request.user
	up=UserProfile.objects.get(user=u)
	return render_to_response('arena.html', {'inventory':up.pipe_inventory,'score':up.score}, context_instance=RequestContext(request))
	

@login_required
def buy(request):
	pipe=request.pipe
	up=request.user
	u=UserProfile.objects.get(user=u)
	inv=up.pipe_inventory.split(',')
	up.pipe_inventory[pipe]+=1
	
	if u.score>=100:
		resp['status']=1
		up.score-=100
	
	up.pipe_inventory=','.join(inv)
	
	resp['inventory']=up.pipe_inventory
	resp['score']=u.score
	json = json.dumps(resp)								#do simplejson if reqd
	return HttpResponse(json, mimetype='application/json')
	
	
@login_required
def logout(request):
    auth.logout(request)
    return HttpResponseRedirect("/login/")

def register(request):
	m=''
	if request.user.is_authenticated():
		return HttpResponseRedirect('/main/')
	if request.POST:

		form=RegistrationForm(request.POST)
		if form.is_valid():
			
			data=form.cleaned_data
			u=User()
			up=UserProfile()
			u.username=data['username']
			u.set_password(data['password'])
			u.email=data['email1']
			try:
				u.save()
			except IntegrityError:
				m='Username already exists'
				return render_to_response('REGIShtml.html',{'message':m},context_instance=RequestContext(request))
			up.name1=data['name1']
			up.name2=data['name2']
			up.phone1=data['phone1']
			up.phone2=data['phone2']
			up.email1=data['email1']
			up.email2=data['email2']
			up.user=u
			up.save()
			return HttpResponseRedirect('/login/')
		else:
			return render_to_response('REGIShtml.html',{'message':m},context_instance=RequestContext(request))
	else:
		form=RegistrationForm()
		return render_to_response('REGIShtml.html',{'form':form},context_instance=RequestContext(request))

@login_required
def validate(request):
	u=request.user
	up=UserProfile.objects.get(user=u)
	r={}
	s=request.snapshot
	x=check_success(s,0,0,2,5,4,3)
	inv=up.pipe_inventory.split(',')
	
	if x:
		for i in s:
			if i>0:
				inv[i-1]-=1
			if inv[i-1]<0:
				r['status']=-1
				inv = up.pipe_inventory.split(',')
	else:		
		r['status']=0
	if r['status']==1:
		up.score +=x*200			#document this
		if x>18:
			up.score +=1000
		elif x>12:
			up.score +=500
	r['score']=up.score
	r['inventory']=up.pipe_inventory
	json = json.dumps(resp)								#do simplejson if reqd
	return HttpResponse(json, mimetype='application/json')
	
		

def check_success(s,i,j,ent,desti,destj,destent):
	"Checks the array to contain pipe path from start to end"
	
	pipe_map ={
	#no problem in exchanging key for any pipe just make sure it's value is right
	"p0": 0, #if no pipe then value zero
	"p1": 14,
	"p2": 35,
	"p3": 6,
	"p4": 15,
	"p5": 10,
	"p6": 21,
	}
	#	ent is the entry point for the pipe
	#	the numbers associated with box is
	#	2 - left; 3 - top; 5 - right; 7 - bottom
	#	prime numbers are used so that we can define pipes with product of this numbers
	#This function requires:
	#	array which you have to check
	#	json for maping of value in array to followed convention
	#	source coordinates
	#	initial entry point
	#	destination coordinates where you have to reach
	#	destination entry point
	success = False
	count,ext,num=0,0,0
	while (i>=0 and i<len(s) and j>=0 and j<len(s[0])):
		num = int(pipe_map["p"+str(s[(i*5)+j])])
		if (num==0 or num%ent != 0):
			break
		else:
			count+=1
			ext = num/ent
			if (ext==7):
				i+=1
				ent=3
			elif (ext==5):
				j+=1
				ent=2
			elif (ext==3):
				i-=1
				ent=7
			elif (ext==2):
				j-=1
				ent=5
			elif (ext*ent==210):
				if (ext%21==0):
					if ent==2:
						i+=1 
					else:
						i-=1
				else:
					if ent==2:
						j+=1 
					else:
						j-=1
			else:
				return 0
		if (i==desti and j==destj and ent==destent):
			success = True
			break
	return count if success else 0

